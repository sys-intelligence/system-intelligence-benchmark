---
- hosts: all
  gather_facts: yes
  become: true
  vars:
    docker_key_url: https://download.docker.com/linux/ubuntu/gpg
    docker_repo: "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
    # kube_version: "1.31.0"  # Adjust Kubernetes version as needed
    cri_dockerd_version: "0.3.12.3-0"  # Example version for cri-dockerd, customize as needed

  tasks:
    - name: Kill any stuck apt processes
      shell: |
        pkill -9 apt-get || true
        sleep 2
      become: yes
      ignore_errors: yes
      changed_when: false

    - name: Wait for apt lock to be released
      shell: |
        for i in {1..30}; do
          if ! lsof /var/lib/apt/lists/lock 2>/dev/null && ! lsof /var/cache/apt/archives/lock 2>/dev/null; then
            echo "Lock released"
            break
          fi
          sleep 1
        done
      become: yes
      changed_when: false

    - name: Fix interrupted dpkg state
      shell: dpkg --configure -a
      become: yes
      changed_when: false
      ignore_errors: yes

    # CRITICAL: Install Ubuntu generic 6.8 kernel and headers (must match for dm_dust)
    - name: Install Ubuntu generic 6.8 kernel and matching headers
      apt:
        name:
          - linux-image-generic-6.8
          - linux-headers-generic-6.8
        state: present
        update_cache: yes
      become: yes
      timeout: 900

    - name: Get current running kernel version
      shell: uname -r
      register: current_kernel_check
      changed_when: false

    - name: Get installed Ubuntu generic 6.8 kernel version
      shell: dpkg -l | grep 'linux-image-6.8.0-.*-generic' | grep '^ii' | awk '{print $2}' | sed 's/linux-image-//' | head -1
      register: target_kernel_check
      changed_when: false

    - name: Set kernel version facts
      set_fact:
        current_kernel_version: "{{ current_kernel_check.stdout }}"
        target_kernel_version: "{{ target_kernel_check.stdout }}"
        need_kernel_switch: "{{ current_kernel_check.stdout != target_kernel_check.stdout }}"

    - name: Debug kernel versions
      debug:
        msg: "Current kernel: {{ current_kernel_version }}, Target kernel: {{ target_kernel_version }}, Switch needed: {{ need_kernel_switch }}"

    - name: Set Ubuntu generic kernel as default in GRUB
      shell: |
        KERNEL_VERSION="{{ target_kernel_version }}"
        MENU_ENTRY="Advanced options for Ubuntu>Ubuntu, with Linux $KERNEL_VERSION"
        sed -i "s/^GRUB_DEFAULT=.*/GRUB_DEFAULT=\"$MENU_ENTRY\"/" /etc/default/grub
        update-grub
      become: yes
      when: need_kernel_switch
      register: grub_updated

    - name: Reboot to switch to matching Ubuntu generic kernel
      reboot:
        reboot_timeout: 600
        pre_reboot_delay: 10
        post_reboot_delay: 60
      become: yes
      when: need_kernel_switch

    - name: Wait for system to come back after kernel switch
      wait_for_connection:
        delay: 10
        timeout: 600
      when: need_kernel_switch

    - name: Get current kernel version
      shell: uname -r
      register: kernel_after_fix
      changed_when: false

    - name: Fix apt lock file permissions and clean up
      shell: |
        chmod 644 /var/lib/apt/lists/lock 2>/dev/null || true
        chown root:root /var/lib/apt/lists/lock 2>/dev/null || true
        rm -f /var/cache/apt/archives/lock 2>/dev/null || true
        # Remove lock files that may cause issues
        rm -f /var/lib/dpkg/lock-frontend 2>/dev/null || true
        rm -f /var/lib/dpkg/lock 2>/dev/null || true
      become: yes
      changed_when: false
      ignore_errors: yes

    - name: Remove old Kubernetes repository e.g., v1.29 if it exists
      file:
        path: /etc/apt/sources.list.d/kubernetes.list
        state: absent

    - name: Refresh and upgrade packages
      apt:
        update_cache: "yes"
        upgrade: "yes"

    # - name: Install python3-apt
    #   apt:
    #     name: python3-apt
    #     state: present
    #   become: true

    - name: Remove old Docker versions if any
      apt:
        name: "{{ item }}"
        state: absent
      loop:
        - docker.io
        - docker-doc
        - docker-compose
        - podman-docker
        - containerd
        - runc

    - name: Install prerequisites for Docker and Kubernetes (batched)
      apt:
        name:
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - socat
          - conntrack
          - libssl-dev
        state: present
        update_cache: no
      become: yes

    - name: Add Docker GPG key and repository
      shell: |
        install -m 0755 -d /etc/apt/keyrings
        curl -fsSL {{ docker_key_url }} -o /etc/apt/keyrings/docker.asc
        echo "{{ docker_repo }}" | tee /etc/apt/sources.list.d/docker.list
      args:
        creates: /etc/apt/sources.list.d/docker.list
      become: yes

    - name: Update apt and install Docker
      apt:
        update_cache: yes
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present

    - name: Add user to docker group to run Docker without sudo
      user:
        name: "{{ ansible_user_id }}"
        groups: docker
        append: yes

    - name: Get system architecture
      command: dpkg --print-architecture
      register: system_arch
      changed_when: false

    - name: Download cri-dockerd .deb package (amd64)
      get_url:
        url: "https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.20/cri-dockerd_0.3.20.3-0.ubuntu-jammy_amd64.deb"
        dest: /tmp/install-cri-dockerd.deb
      when: system_arch.stdout == "amd64"

    - name: Install CRI-Dockerd from .deb package (amd64)
      apt:
        deb: /tmp/install-cri-dockerd.deb
        state: present
      when: system_arch.stdout == "amd64"

    - name: Download cri-dockerd .tgz archive (arm64)
      get_url:
        url: "https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.20/cri-dockerd-0.3.20.arm64.tgz"
        dest: /tmp/cri-dockerd.tgz
      when: system_arch.stdout == "arm64"

    - name: Extract cri-dockerd archive (arm64)
      unarchive:
        src: /tmp/cri-dockerd.tgz
        dest: /tmp/
        remote_src: yes
      when: system_arch.stdout == "arm64"

    - name: Install cri-dockerd binaries (arm64)
      copy:
        src: "/tmp/cri-dockerd/{{ item }}"
        dest: "/usr/local/bin/{{ item }}"
        mode: '0755'
        remote_src: yes
      loop:
        - cri-dockerd
      when: system_arch.stdout == "arm64"

    - name: Download cri-dockerd systemd service files (arm64)
      get_url:
        url: "https://raw.githubusercontent.com/Mirantis/cri-dockerd/v0.3.20/packaging/systemd/{{ item }}"
        dest: "/etc/systemd/system/{{ item }}"
      loop:
        - cri-docker.service
        - cri-docker.socket
      when: system_arch.stdout == "arm64"

    - name: Fix cri-dockerd binary path in service file (arm64)
      replace:
        path: /etc/systemd/system/cri-docker.service
        regexp: '/usr/bin/cri-dockerd'
        replace: '/usr/local/bin/cri-dockerd'
      when: system_arch.stdout == "arm64"

    - name: Reload systemd daemon (arm64)
      systemd:
        daemon_reload: yes
      when: system_arch.stdout == "arm64"

    - name: Start and enable cri-dockerd service
      systemd:
        name: cri-docker
        enabled: yes
        state: started

    - name: Check if cri-dockerd socket exists
      stat:
        path: /var/run/cri-dockerd.sock
      register: cri_socket
    
    - name: Install QEMU user-static for x86_64 emulation on ARM nodes
      apt:
        name: qemu-user-static
        state: present
      when: system_arch.stdout == "arm64"
      register: qemu_install

    - name: Verify QEMU registration
      shell: ls /proc/sys/fs/binfmt_misc/ | grep qemu-x86_64
      register: qemu_check
      failed_when: false
      changed_when: false
      when: system_arch.stdout == "arm64"

    - name: Display QEMU status
      debug:
        msg: "QEMU x86_64 emulation is {{ 'enabled' if qemu_check.rc == 0 else 'not found' }}"
      when: system_arch.stdout == "arm64"

    # - name: Wait for cri-dockerd socket to be available
    #   wait_for:
    #     path: /var/run/cri-dockerd.sock
    #     state: present
    #     timeout: 30
    #   when: not cri_socket.stat.exists

    - name: Install Kubernetes packages
      apt:
        name:
          - apt-transport-https
          - curl
          - gpg
        state: present

    # - name: Add Kubernetes GPG key and repository
    #   shell: |
    #     echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/{{ kube_version }}/deb/ /" | sudo tee /etc/apt/sources.list.d/kubernetes.list
    #     curl -fsSL https://pkgs.k8s.io/core:/stable:/{{ kube_version }}/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
    #   args:
    #     creates: /etc/apt/sources.list.d/kubernetes.list

    - name: Remove existing Kubernetes GPG key if it exists
      file:
        path: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        state: absent

    - name: Add Kubernetes GPG key
      shell: |
        curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
      args:
        creates: /etc/apt/keyrings/kubernetes-apt-keyring.gpg
      become: yes

    - name: Add Kubernetes repository for v1.31
      shell: |
        echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /' | tee /etc/apt/sources.list.d/kubernetes.list
      args:
        creates: /etc/apt/sources.list.d/kubernetes.list
      become: yes

    - name: Install kubeadm, kubelet, kubectl
      apt:
        update_cache: yes
        name:
          - kubeadm
          - kubelet
          - kubectl
        state: present

    # - name: Hold Kubernetes packages at installed version
    #   apt:
    #     name:
    #       - kubeadm
    #       - kubelet
    #       - kubectl
    #     state: present
    #     mark: hold

    - name: Hold Kubernetes packages at installed version
      shell: |
        apt-mark hold kubeadm kubelet kubectl
      become: yes

    - name: Disable swap
      shell: |
        swapoff -a
        sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
      become: yes
      ignore_errors: yes
      changed_when: false

    - name: Install software-properties-common for PPA support
      apt:
        name: software-properties-common
        state: present
        update_cache: yes
      become: yes

    - name: Verify kernel matches headers
      assert:
        that:
          - kernel_after_fix.stdout is defined
          - "'6.8.0-' in kernel_after_fix.stdout"
          - "'-generic' in kernel_after_fix.stdout"
        fail_msg: "Kernel doesn't match expected Ubuntu generic format. Current: {{ kernel_after_fix.stdout | default('undefined') }}"
        success_msg: "Kernel matches Ubuntu generic 6.8: {{ kernel_after_fix.stdout }}"

    - name: Confirm kernel and headers match
      debug:
        msg: "Running kernel: {{ kernel_after_fix.stdout }} (should match headers)"

    - name: Remove broken kernel headers if they cause dependency issues
      shell: |
        # Remove any broken headers that prevent package installation
        dpkg -l | grep "linux-headers.*6\.8\." | grep -v "^ii" | awk '{print $2}' | xargs -r apt-get remove --purge -y || true
        # Also remove headers with unmet dependencies
        if apt-get check 2>&1 | grep -q "linux-headers.*6\.8"; then
          dpkg -l | grep "linux-headers.*6\.8\." | awk '{print $2}' | xargs -r apt-get remove --purge -y || true
        fi
        apt-get install -f -y || true
      ignore_errors: yes
      become: yes

    - name: Install additional packages for module building
      apt:
        name:
          - flex
          - bison
          - bc
          - libelf-dev
          - build-essential
          - gcc-12
        state: present
        update_cache: no
      become: yes

    - name: Get full kernel version
      shell: uname -r
      register: kernel_version_full
      changed_when: false

    - name: Check if dm_dust and dm_flakey modules exist
      shell: |
        DUST=$(modinfo dm_dust 2>/dev/null && echo "exists" || echo "not_found")
        FLAKEY=$(modinfo dm_flakey 2>/dev/null && echo "exists" || echo "not_found")
        echo "dm_dust:$DUST"
        echo "dm_flakey:$FLAKEY"
      register: dm_modules_check
      changed_when: false

    - name: Set module facts (reusable throughout playbook)
      set_fact:
        dm_dust_exists: "{{ 'dm_dust:exists' in dm_modules_check.stdout }}"
        dm_flakey_exists: "{{ 'dm_flakey:exists' in dm_modules_check.stdout }}"

    - name: Check if Ubuntu kernel headers are available
      stat:
        path: "/usr/src/linux-headers-{{ kernel_version_full.stdout }}"
      register: ubuntu_headers
      changed_when: false

    - name: Install generic 6.8 kernel headers (should already match running kernel)
      apt:
        name: linux-headers-generic-6.8
        state: present
        update_cache: no
      when: >
        (not dm_dust_exists or not dm_flakey_exists)
        and not ubuntu_headers.stat.exists
      become: yes
      ignore_errors: yes

    - name: Re-check headers after installation attempt
      stat:
        path: "/usr/src/linux-headers-{{ kernel_version_full.stdout }}"
      register: ubuntu_headers
      changed_when: false

    - name: Fail if headers not available
      fail:
        msg: "Kernel headers not available for {{ kernel_version_full.stdout }}. Cannot build modules."
      when: >
        (not dm_dust_exists or not dm_flakey_exists)
        and not ubuntu_headers.stat.exists

    - name: Check if build symlink exists
      stat:
        path: "/lib/modules/{{ kernel_version_full.stdout }}/build"
      register: build_symlink
      changed_when: false
      when: >
        (not dm_dust_exists or not dm_flakey_exists)
        and ubuntu_headers.stat.exists

    - name: Create build symlink if headers exist but symlink is missing
      file:
        src: "/usr/src/linux-headers-{{ kernel_version_full.stdout }}"
        dest: "/lib/modules/{{ kernel_version_full.stdout }}/build"
        state: link
      become: yes
      when: >
        (not dm_dust_exists or not dm_flakey_exists)
        and ubuntu_headers.stat.exists
        and (build_symlink is defined and (not build_symlink.stat.exists or not build_symlink.stat.islnk))

    - name: Ensure kernel module directory exists
      file:
        path: "/lib/modules/{{ kernel_version_full.stdout }}/kernel/drivers/md"
        state: directory
        mode: '0755'
      become: yes
      when: not dm_dust_exists or not dm_flakey_exists

    - name: Load dm_dust module if available
      modprobe:
        name: dm_dust
        state: present
      when: dm_dust_exists
      ignore_errors: yes
      become: yes

    - name: Build and install dm_dust module if not available
      block:
        - name: Create dm-dust build directory
          file:
            path: /tmp/dm-dust-build
            state: directory

        # Download kernel source for dm-dust.c
        - name: Extract kernel major.minor version
          set_fact:
            kernel_major_minor: "{{ kernel_version_full.stdout | regex_replace('^([0-9]+\\.[0-9]+).*', '\\1') }}"

        - name: Debug kernel version for download
          debug:
            msg: "Full kernel: {{ kernel_version_full.stdout }}, Major.Minor: {{ kernel_major_minor }}"

        - name: Check if kernel source already downloaded
          stat:
            path: /tmp/linux-{{ kernel_major_minor }}.tar.xz
          register: kernel_source_exists

        - name: Download kernel source for dm-dust source code
          get_url:
            url: "https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-{{ kernel_major_minor }}.tar.xz"
            dest: /tmp/linux-{{ kernel_major_minor }}.tar.xz
          when: not kernel_source_exists.stat.exists
          register: kernel_source_download

        - name: Check if kernel source already extracted
          stat:
            path: /tmp/linux-{{ kernel_major_minor }}/drivers/md/dm-dust.c
          register: dm_dust_source_exists

        - name: Extract only the dm-dust source file from kernel tarball
          shell: |
            cd /tmp
            tar -xJf linux-{{ kernel_major_minor }}.tar.xz linux-{{ kernel_major_minor }}/drivers/md/dm-dust.c
          when: not dm_dust_source_exists.stat.exists
          args:
            creates: /tmp/linux-{{ kernel_major_minor }}/drivers/md/dm-dust.c

        - name: Copy dm-dust source to build directory
          shell: |
            cp /tmp/linux-{{ kernel_major_minor }}/drivers/md/dm-dust.c /tmp/dm-dust-build/dm-dust.c
          args:
            creates: /tmp/dm-dust-build/dm-dust.c

        - name: Create Makefile for dm-dust (use system headers)
          copy:
            dest: /tmp/dm-dust-build/Makefile
            content: |
              obj-m := dm-dust.o
              KDIR := /lib/modules/$(shell uname -r)/build
              PWD := $(shell pwd)
              CC := gcc-12

              default:
              	$(MAKE) -C $(KDIR) M=$(PWD) modules CC=gcc-12

              clean:
              	$(MAKE) -C $(KDIR) M=$(PWD) clean

              install:
              	mkdir -p /lib/modules/$(shell uname -r)/kernel/drivers/md/
              	cp dm-dust.ko /lib/modules/$(shell uname -r)/kernel/drivers/md/
              	depmod -a
            mode: '0644'

        - name: Check if dm-dust module already built
          stat:
            path: /tmp/dm-dust-build/dm-dust.ko
          register: dm_dust_ko_precheck

        - name: Build dm-dust module
          make:
            chdir: /tmp/dm-dust-build
          environment:
            KBUILD_MODPOST_WARN: "1"
            CC: "gcc-12"
          ignore_errors: yes
          register: dm_dust_build_result
          when: not dm_dust_ko_precheck.stat.exists

        - name: Verify dm_dust module was built successfully
          stat:
            path: /tmp/dm-dust-build/dm-dust.ko
          register: dm_dust_ko
          failed_when: not dm_dust_ko.stat.exists
          ignore_errors: yes

        - name: Install dm-dust module
          make:
            chdir: /tmp/dm-dust-build
            target: install
          become: yes
          ignore_errors: yes
          when: dm_dust_ko.stat.exists | default(false)

        - name: Verify dm_dust module is installed
          stat:
            path: "/lib/modules/{{ kernel_version_full.stdout }}/kernel/drivers/md/dm-dust.ko"
          register: dm_dust_installed
          failed_when: false
          changed_when: false

        - name: Load dm_dust module
          modprobe:
            name: dm_dust
            state: present
          become: yes
          ignore_errors: yes
          register: dm_dust_load_result

        - name: Debug dm_dust module load result
          debug:
            msg: "dm_dust module load result: {{ dm_dust_load_result }}"

        - name: Verify dm_dust module can be loaded
          shell: |
            modprobe dm_dust
            lsmod | grep -q "^dm_dust" || exit 1
            dmsetup targets | grep -q "dust" || exit 1
            echo "dm_dust module is loaded and functional"
          become: yes
          register: dm_dust_load_test
          failed_when: dm_dust_load_test.rc != 0
          changed_when: false
          ignore_errors: yes

        - name: Clean up build directory after successful install
          file:
            path: /tmp/dm-dust-build
            state: absent
          when: dm_dust_installed.stat.exists
      when: not dm_dust_exists

    - name: Load dm_flakey module (built into kernel 6.8.x)
      modprobe:
        name: dm_flakey
        state: present
      ignore_errors: yes
      become: yes

    - name: Load necessary kernel modules
      shell: |
        modprobe overlay
        modprobe br_netfilter
        modprobe dm_dust || true
        modprobe dm_flakey || true
      become: yes
      args:
        creates: /etc/modules-load.d/k8s.conf

    - name: Create modules-load configuration for Kubernetes and modules
      copy:
        content: |
          overlay
          br_netfilter
          dm_dust
          dm_flakey
        dest: /etc/modules-load.d/k8s.conf
      become: yes

    - name: Configure sysctl for Kubernetes networking
      copy:
        content: |
          net.bridge.bridge-nf-call-iptables  = 1
          net.bridge.bridge-nf-call-ip6tables = 1
          net.ipv4.ip_forward                 = 1
        dest: /etc/sysctl.d/k8s.conf
      notify: Reload sysctl

    - name: Start and enable kubelet
      systemd:
        name: kubelet
        enabled: yes
        state: started

  handlers:
    - name: Install CRI-Dockerd
      apt:
        deb: /tmp/cri-dockerd.deb

    - name: Reload sysctl
      command: sysctl --system
      become: yes

# Control Node Setup
- hosts: control_node  # Control plane tasks
  become: true
  vars:
    kubeconfig_path: "/users/{{ k8s_user }}/.kube/config"
  tasks:
    - name: Resolve control node hostname to IP
      command: getent ahosts "{{ hostvars['control_node'].ansible_host }}"
      register: resolved_ip_output
    - name: Parse resolved IP from output
      set_fact:
        resolved_control_plane_ip: "{{ resolved_ip_output.stdout_lines[0].split(' ')[0] }}"
    - name: Set resolved_control_plane_ip globally
      add_host:
        name: "global"
        resolved_control_plane_ip: "{{ resolved_control_plane_ip }}"
    - name: Initialize Kubernetes control plane
      shell: |
        kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket /var/run/cri-dockerd.sock --apiserver-advertise-address={{ resolved_control_plane_ip }}
      args:
        creates: /etc/kubernetes/admin.conf
    - name: Ensure .kube directory exists
      file:
        path: "/users/{{ k8s_user }}/.kube"
        state: directory
        mode: '0755'
        owner: "{{ k8s_user }}"
        # group: "{{ k8s_user }}"
      become: true
    - name: Temporarily set permissions to read admin.conf
      file:
        path: /etc/kubernetes/admin.conf
        mode: '0644'
      become: true
    
    - name: Set up kube config for kubectl on control plane
      copy:
        src: /etc/kubernetes/admin.conf
        dest: "/users/{{ k8s_user }}/.kube/config"
        mode: '0644'
        remote_src: true
      become: true
      become_method: sudo
    - name: Ensure ownership of kube config for kubectl
      file:
        path: "/users/{{ k8s_user }}/.kube/config"
        owner: "{{ k8s_user }}"
        # group: "{{ k8s_user }}"
        mode: '0644'
      become: true
    - name: Display ansible_user_id
      debug:
        msg: "ansible_user_id is {{ ansible_user_id }}"
    
    - name: Fetch admin.conf to localhost for kubeconfig
      fetch:
        src: /etc/kubernetes/admin.conf
        dest: ~/.kube/config
        flat: yes
      become: true
    - name: Generate kubeadm join command
      shell: kubeadm token create --print-join-command
      register: kubeadm_join_command
    - name: Extract kube_token and cert_hash from join command
      set_fact:
        kube_token: "{{ (kubeadm_join_command.stdout | regex_search('--token\\s+([\\w.]+)', '\\1')).0 }}"
        cert_hash: "{{ (kubeadm_join_command.stdout | regex_search('--discovery-token-ca-cert-hash\\s+sha256:([\\w]+)', '\\1')).0 }}"
  
    - name: Display kube_token
      debug:
        msg: "kube_token is {{ kube_token }}"
    - name: Display cert_hash
      debug:
        msg: "cert_hash is {{ cert_hash }}"
    - name: Install Flannel network plugin
      shell: |
        kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml
      args:
        creates: /etc/kubernetes/kube-flannel.yml
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
    - name: Untaint the control plane to host pods
      shell: kubectl taint nodes $(hostname) node-role.kubernetes.io/control-plane:NoSchedule- || true
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
# Worker Node Setup
- hosts: worker_nodes
  become: true
  tasks:
    - name: Join Kubernetes cluster
      shell: |
        kubeadm join {{ hostvars['global'].resolved_control_plane_ip }}:6443 --token {{ hostvars['control_node'].kube_token }} --discovery-token-ca-cert-hash sha256:{{ hostvars['control_node'].cert_hash }} --cri-socket unix:///var/run/cri-dockerd.sock --v=5
      args:
        creates: /var/lib/kubelet/kubeadm-flags.env
      become: true
    - name: Ensure .kube directory exists
      file:
        path: "/users/{{ ansible_user }}/.kube"
        state: directory
        mode: '0755'
      become_user: "{{ ansible_user }}"  # Ensure directory is created under the correct user
    - name: Display ansible_user
      debug:
        msg: "ansible_user is {{ ansible_user }}"

# Label Worker Nodes
- hosts: control_node
  become: true
  vars:
    kubeconfig_path: "/users/{{ k8s_user }}/.kube/config"
  tasks:
    - name: Wait for worker nodes to be ready
      shell: |
        timeout=120
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          if kubectl get nodes --no-headers | grep -v "control-plane\|master" | grep -q "Ready"; then
            echo "Worker nodes are ready"
            exit 0
          fi
          sleep 2
          elapsed=$((elapsed + 2))
        done
        echo "Timeout waiting for worker nodes after ${timeout}s"
        exit 1
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      ignore_errors: yes

    - name: Get all node names
      shell: kubectl get nodes --no-headers -o custom-columns=NAME:.metadata.name
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: all_nodes
      changed_when: false

    - name: Label worker nodes with node-role.kubernetes.io/worker
      shell: |
        node="{{ item }}"
        # Get node labels as YAML and check for control-plane/master labels
        node_yaml=$(kubectl get node "$node" -o yaml)
        if echo "$node_yaml" | grep -q "node-role.kubernetes.io/control-plane:" || echo "$node_yaml" | grep -q "node-role.kubernetes.io/master:"; then
          echo "Skipping control plane node: $node"
        elif echo "$node_yaml" | grep -q "node-role.kubernetes.io/worker:"; then
          echo "Node $node already has worker label"
        else
          kubectl label node "$node" node-role.kubernetes.io/worker= --overwrite
          echo "Labeled $node as worker"
        fi
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      loop: "{{ all_nodes.stdout_lines }}"
      ignore_errors: yes
      register: label_result

    - name: Display labeling result
      debug:
        msg: "{{ label_result.stdout_lines | default(['No output']) }}"